exec("""\nimport sys\nimport traceback\n\n\ndef check_usage_possibility(func, importing_module=None):\n    def inner(*args, **kwargs):\n        usage_counter = 0\n        stack = traceback.extract_stack()\n        for line in stack:\n            if line[0] == '<string>':\n                usage_counter += 1\n        try:\n            if not importing_module:\n                banned_function = inner.__name__\n                if usage_counter == len(stack):\n                    raise PermissionError(f"Function {banned_function} not allowed to use")\n\n            banned_import = args[0]\n            if usage_counter == len(stack) and banned_import == importing_module:\n                raise PermissionError(f"Module {banned_import} not allowed to use")\n\n        except PermissionError as message:\n            print(message)\n            sys.exit()\n\n        return func(*args, **kwargs)\n\n    inner.__name__ = func.__name__\n    return inner\n\n\nfor banned_import in sys.argv[1].split(','):\n    __builtins__.__dict__['__import__'] = check_usage_possibility(__builtins__.__dict__['__import__'], banned_import)\nfor banned_function in sys.argv[2].split(','):\n    __builtins__.__dict__[banned_function] = check_usage_possibility(__builtins__.__dict__['exec'])\n\ndel check_usage_possibility\n""")
